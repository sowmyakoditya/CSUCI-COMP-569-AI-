# -*- coding: utf-8 -*-
"""UCS_TreeAndGraphMode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-uo389T_Om8ilGAjyM1IRX_xkmU4EQyN
"""



sample_maze_map = [
    "-------------",
    "-R6666633331-",
    "-336161333-6-",
    "-111161111-6-",
    "-----6111166-",
    "-1111616-1-3-",
    "-1166---11-3-",
    "-11666D131-3-",
    "-111113333-3-",
    "-61111333333-",
    "-------------"
  ]

m, n = (len(sample_maze_map), len(sample_maze_map))
visited_blocks = [[False for i in range(13)]
                      for j in range(11)]

class Node:
    def __init__(self, loc, parent, cost):
        self.cost = cost
        self.parent = parent
        self.location = loc

class Bot:
    def __init__(self, map):
        self.map = map
        self.map_height = len(map)
        self.map_width = len(map[0])

    def left(self, current_loc):
        x = current_loc[0]
        y = current_loc[1]
        x_moved = current_loc[0]
        if self.map[y][x-1] != "-":
          next_location = self.map[y][x-1]
          x_moved = x-1
          return (x_moved, y)
        elif x == x_moved:
          raise IndexError
        else:
          raise IndexError

    def right(self, current_loc):
        x = current_loc[0]
        y = current_loc[1]
        x_moved = current_loc[0]

        if self.map[y][x+1] != "-":
          next_location = self.map[y][x+1]
          x_moved = x+1
          return (x_moved, y)
        elif x == x_moved:
          raise IndexError
        else:
          raise IndexError

    def up(self, current_loc):
        x = current_loc[0]
        y = current_loc[1]
        y_moved = current_loc[1]

        if self.map[y-1][x] != "-":
          next_location = self.map[y-1][x]
          y_moved = y-1
          return (x, y_moved)
        elif y == y_moved:
          raise IndexError
        else:
          raise IndexError

    def down(self, current_loc):
        x = current_loc[0]
        y = current_loc[1]
        y_moved = current_loc[1]

        if self.map[y+1][x] != "-":
          next_location = self.map[y+1][x]
          y_moved = y+1
          return (x, y_moved)
        elif y == y_moved:
          raise IndexError
        else:
          raise IndexError

def get_StartAndGoal(map):
    start = "R"
    goal = "D"
    start_loc = None
    goal_loc = None

    for indx, row in enumerate(map):
        if start_loc == None and start in row:
            start_loc = (row.find(start), indx)
        if goal_loc == None and goal in row:
            goal_loc = (row.find(goal), indx)
        if start_loc != None and goal_loc != None:
            break

    return start_loc, goal_loc

def funct_extractPlan(goal_node):
     current_node = goal_node
     temp_path = []

     while True:
         temp_path.append(current_node.location)
         current_node = current_node.parent
         if current_node is None:
            break

     result_path = [temp_path.pop() for i in range(len(temp_path))]
     return result_path, goal_node.cost

# Uniform Cost Search - Graph Mode

def successor_funct_Graph(current_node, robot, map):
    functions = [robot.up, robot.down, robot.left, robot.right]
    children = []

    for f in functions:
        try:
            moved_loc = f(current_node.location)
            child = Node(loc=moved_loc, parent=current_node, cost=current_node.cost + 1)
            children.append(child)
        except IndexError:
          continue
    tempChild = []
    for c in children:
      thsLoc = c.location
      try:
        if map[thsLoc[0]][thsLoc[1]] != "-" or visited_blocks[thsLoc[0]][thsLoc[1]] != True:
          indx = 0
          for i in range(len(tempChild)):
            tempLoc = tempChild[i].location
            if map[thsLoc[0]][thsLoc[1]] > map[tempLoc[0]][tempLoc[1]]:
              indx = i+1
          tempChild.insert(indx, c)
      except:
        continue
    children = tempChild
    return children

def ucs_graph(map):
    start_loc, goal_loc = get_StartAndGoal(map)
    fringe = [Node(start_loc, None, 0)]
    
    while True:
        
        if not fringe:
            "Failure in finding plan"
        
        current_node = fringe.pop(0)
        currLoc = current_node.location
        if visited_blocks[currLoc[0]][currLoc[1]] != True:
          if current_node.location == goal_loc:
              return funct_extractPlan(current_node)
          else:
            visited_blocks[currLoc[0]][currLoc[1]] = True
            fringe += successor_funct_Graph(current_node, Bot(map), map)

def play_game_GraphMode():
  result = ucs_graph(sample_maze_map)
  if isinstance(result, tuple):
    final_res = []
    x = 0
    y = 0
    plan =result[0]
    cst = 0
    for i in range(len(plan)):
      if plan[i][0]<x and plan[i][1]==y:
        final_res.append("Left")
      elif plan[i][0]>x and plan[i][1]==y:
        final_res.append("Right")
      elif plan[i][1]<y and plan[i][0]==x:
        final_res.append("Up")
      elif plan[i][1]>y and plan[i][0]==x:
        final_res.append("Down")
      
      x = plan[i][0]
      y = plan[i][1]
    print("Uniform Cost Search - Graph Mode")
    print("")
    print("Cost ", result[1])
    print("Plan ", result[0])
      
    print('->'.join(final_res))
    print("------------")

play_game_GraphMode()

# ----------------------------------------------------
# Uniform Cost Search - Tree Mode

def successor_funct_Tree(current_node, robot, map):
    functions = [robot.up, robot.down, robot.left, robot.right]
    children = []

    for f in functions:
        try:
            moved_loc = f(current_node.location)
            child = Node(loc=moved_loc, parent=current_node, cost=current_node.cost + 1)
            children.append(child)
        except IndexError:
          continue
    tempChild = []
    for c in children:
      thsLoc = c.location
      if map[thsLoc[0]][thsLoc[1]] != "-":
        indx = 0
        for i in range(len(tempChild)):
          tempLoc = tempChild[i].location
          if map[thsLoc[0]][thsLoc[1]] > map[tempLoc[0]][tempLoc[1]]:
            indx = i+1
        tempChild.insert(indx, c)
    children = tempChild
    return children

def ucs_tree(map):
    start_loc, goal_loc = get_StartAndGoal(map)
    fringe = [Node(start_loc, None, 0)]

    while True:
        
        if not fringe:
            "Failure in finding plan"
        
        current_node = fringe.pop(0)
        
        if current_node.location == goal_loc:
            return funct_extractPlan(current_node)
        else:
            fringe += successor_funct_Tree(current_node, Bot(map), map)


def play_game_TreeMode():
  result = ucs_tree(sample_maze_map)
  if isinstance(result, tuple):
    final_res = []
    x = 0
    y = 0
    plan =result[0]
    for i in range(len(plan)):
      if plan[i][0]<x and plan[i][1]==y:
        final_res.append("Left")
      elif plan[i][0]>x and plan[i][1]==y:
        final_res.append("Right")
      elif plan[i][1]<y and plan[i][0]==x:
        final_res.append("Up")
      elif plan[i][1]>y and plan[i][0]==x:
        final_res.append("Down")
      
      x = plan[i][0]
      y = plan[i][1]

    print("Cost ", result[1])
    print("Plan ", result[0])
      
    return '->'.join(final_res)
 

play_game_TreeMode()